\chapter{Programming in FORTH}

This chapter briefly reviews the main ideas of FORTH to let the reader understand the program fragments and subroutines that comprise the meat of this book. We make no pretense to complete coverage of standard FORTH programming methods. \textbf{Chapter 2 is not a programmer’s manual!}

Suppose the reader is stimulated to try FORTH - how can he proceed? Several excellent FORTH texts and references are available: \textit{Starting FORTH} \footnote{L. Brodie, \textit{Starting FORTH}, 2nd ed. (Prentice-Hall, NJ, 1986), referred to hereafter as \textbf{SF}.} and \textit{Thinking FORTH} \footnote{L. Brodie, \textit{Thinking FORTH} (Prentice-Hall, NJ 1984), referred to hereafter as \textbf{TF}.} by Leo Brodie; and \textit{ FORTH: a Text and Reference} \footnote{M. Kelly and N. Spies, FORTH: a Tea and Reference (Prentice-Hall, NJ , 1986), referred to hereafter as \textbf{FTR}.} by M.Kelly and N.Spies. I strongly recommend reading \textbf{FTR} or \textbf{SF} (or both) before trying to use the ideas from this book on a FORTH system. (Or at least read one concurrently.)

The (commercial) GEnie information network maintains a session devoted to FORTH under the aegis of the Forth Interest Group (fiG).

FIG publishes a journal \textit{Forth Dimensions} whose object is the exchange of programming ideas and clever tricks.

The Association for Computing Machinery (11 West 42nd St., New York, NY 10036) maintains a Special Interest Group on FORTH (SIGForth).

The Institute for Applied FORTH Research (Rochester, NY) publishes the refereed \textit{Journal of FORTH Application and Research}, that serves as a vehicle for more scholarly and theoretical papers dealing with FORTH.

finally, an attempt to codify and standardize FORTH is underway, so by the time this book appears the first draft of an ANS FORTH and extensions may exist.

\section{The structure of FORTH}

The "atom" of FORTH is a \textbf{word} a previously-defined operation (defined in terms of machine code or other, previously-defined words) whose definition is stored in a series of linked lists called the \textbf{dictionary}. The FORTH operating system is an endless loop (outer interpreter) that reads the console and interprets the input stream, consulting the dictionary as necessary. If the stream contains a word \footnote{Successive words in the input stream are separated from each other by blank spaces. ASCII "at, the standard FORTH delimiter.} in the dictionary the interpreter immediately executes that word.

Input? Yes
No Interpret
ok

Interpret
word? Yes EXECUTE
number? Yes NUMBER
ERROR
fig. 2-1 Overview of FORTH outer interpreter

In general, because FORTH is interpretive as well as compiled, the best way to study something new is in front of a computer running FORTH. Therefore we explain with illustrations, expecting the reader to try them out. \\

In what follows, anything the user types in will be set in \lstinline$Helvetica$, such as \lstinline$DECIMAL$ below. \\

Machine responses appear in ordinary type. \\ 

We now give a trivial illustration:

\begin{lstlisting}
DECIMAL <cr> ok
\end{lstlisting}

\underline{\textbf{Notes}}:
\begin{itemize}
  \item \lstinline$<cr>$ means "the user pushes the ENTER or <= button".
  \item ok is what FORTH says in response to an input line, if nothing has gone wrong.
  \item DECIMAL is an instruction to use base 10 arithmetic. FORTH will use any base on tell it, within reason, but usually only DECIMAL and HEX (hexadecimal) are predefined.
\end{itemize}

When the outer interpreter (see fig. 2.1 on p. 13) encounters text with no dictionary entry, it tries to interpret it as a \textbf{\lstinline$NUMBER$}. \\

It places the number in a special memory location called "the top of the stack" (TOS)  \footnote{We will explain about the stack in §2.3.}
\begin{lstlisting}
2 17 +. <cr> 19 ok
\end{lstlisting}

\underline{\textbf{Notes}}:
\begin{itemize}
  \item FORTH interprets 2 and 17 as numbers, and pushes them onto the stack. " \lstinline$+$ " is a word and so is " \lstinline$.$ " so they are \textbf{\lstinline$EXECUTE$}d.
  \item \lstinline$+$ adds 2 to 17 and leaves 19 on the stack.
  \item The word . (called "emit") removes 19 from the stack and displays it on the screen.
\end{itemize}

We might also have said \footnote{since FORTH uses words, when we enter an input line we say the corresponding phrase.}

HEX 0A 14 * . <cr> C8 ok

(Do you understand this? Hint: \textbf{HEX} stands for "switch to hexadecimal arithmetic")

If the incoming text can neither be located in the dictionary nor interpreted as a number, FORTH issues an error message.


\section{Extending the dictionary}

The compiler is one of FORTl-I’s most endearing features. It is elegant, simple, and mostly written in FORTH. Although the technical details of the FORTH compiler are generally more interesting to systems developers than to scientists, its components can often be used to solve programming problems. When this is the case, we necessarily discuss details of the compiler. In this section we discuss how the compiler extends the dictionary. In §2§§8 below we examine the parts of the compiler in greater detail.

FORTH has special words that allow the creation of new dictionary entries, i.e., new words. The most important are " : " ("start a new definition") and " ; " ("end the new definition").

Consider the phrase

: NEW-WORD WORD1 17 WORDZ . . . WORDn ; ok

The initial " : " is \textit{EXECUTE}d because it is already in the dictionary. Upon execution, " : " does the following:

\begin{itemize}
    \item Creates a new dictionary entry, \textbf{NEW-WORD}, and switches from interpret- to compile mode.
    \item In compile mode, the interpreter looks up words and — rather than executin them — installs ointers to their code. If the text is a number ( 7 above), FOR builds the literal number into
the dictionary space allotted for \textbf{NEW-WORD}.
    \item The action of \textbf{NEW-WORD} will be to \textbf{EXECUTE} sequentially the previously-defined words \textbf{WORD1}, \textbf{WORD2}, ...\textbf{WORDn}, placing any built-in numbers on the stack as they occur.
    \item The FORTH co aililerpo \textbf{EXECUTE}s the last word " ; " of the definition, by installing code (to return control to the next outer level of the interpreter \footnote{This level could be either the outer interpreter or a word that invokes \textbf{ NEW-WORD}.}) then switching back from compile to interpret mode. Most other languages treat tokens like " ; " as ﬂags (in the input stream) that \textit{trigger} actions, rather than actions in their own right FORTH lets components execute themselves.
\end{itemize}

In FORTH \textit{all} subroutines are words that are invoked when they are named. No explicit CALL or GOSUB statement is required.

The above definition of \textbf{NEW-WORD} is extremely structured compared with FORTRAN or BASIC. Its definition is just a series of subroutine calls.

We now illustrate how to define and use a new word using the previously defined words " : "and " ; ". Enter the phrase (this new word *+ expects 3 numbers, a, b, and c on the stack)

: *+ 	* + ; ok

\underline{Notes:}
\begin{itemize}
	\item * multiplies b with c, leaving b*c.
	\item + then adds b*c to a, leaving a + b*c behind.
\end{itemize}

Now we actually try out a + :
DECIMAL 5 6 7 *+ . 47 ok

\underline{Notes:}
\begin{itemize}
	\item The period . is not a typo, it EMlTs the result.
	\item FORTH’s response to a b c *+ . is a + b*c ok.
\end{itemize}

What if we were to enter *+ with nothing on the stack? Let's try it and see ( .S is a word that displays the stack without changing its contents):

.S empty stack ok

*+ empty stack ok

\underline{Exercise:}
Suppose you entered the input line

HEX 5 6 7 *+ . <cr> xxx ok

What would you expect the response xxx to be?

\textit{Answer: 2F}

\section{Stacks and reverse Polish notation (RPN)}

We now discuss the stack and the "reverse Polish" or "postfix" arithmetic based on it. (Anyone who has used one of the Hewlett-Packard calculators should already be familiar with the basic concepts.)

A Polish mathematician (J .Lukasewcleia) showed that numerical calculations require an irreducible minimum of elementary operations (f\textit{etc}hing and storing numbers as well as addition, subtraction, multiplication and division). The minimum is obtained when the calculation is organized by "stack" arithmetic.

Thus virtually all central processors (CPU’s) intended for arithmetic operations are designed around stacks. FORTH makes efficient use of CPU's by reflecting this underlying stack architecture in its syntax, rather than translating algebraic-looking program statements ("infix" notation) into RPN-based machine operations as FORTRAN, BASIC, C and Pascal do.

But what is a stack? As the name implies, a stack is the machine analog of a pile of cards with numbers written on them. Numbers are always added to, and removed from, the top of the pile. (That is, a stack resembles a job where layoffs follow seniority: last in, first out.) Thus, the FORTH input line

DECIMAL 2 5 73 -16 ok

followed by the line

+ - * . yyy ok

leaves the stack in the successive states shown in Table 2-1 below 

Cell\# 	Initial 	Ops-> 	+ 	-	*	.
0 		-16 		Result 	57 	-52	104	...
1 		73 		-> 		5 	2	...	...
2 		5 		2		...	...
3 		2		...		...

 Table 2-1 \textit{Picture of the stack during operations}

We usually employ zero-based relative numbering in FORTH data structures —stacks, arrays, tables,  \textit{\textit{etc}}.  — so TOS ("top of stac ") is given relative \#0, NOS ("next on stack") \#1, \textit{\textit{etc}}.

The operation ``.'' ("emit") displays -104 to the screen, leaving the stack empty. That is, yyy above is -104.

\section{Manipulating the parameter stack}

FORTH system incorporate (at least) two stacks: the parameter stack which we now discuss, and the return stack which we defer to 2.3.2.

In order to use a stack-based system, we must be able to put numbers on the stack, remove them, and rearrange their order. FORTH includes standard words for this purpose.

Putting numbers on the stack is easy: one simply types the number (or it appears in the definition of a FORTH word).

To remove a number we have the word DROP that drops the number from TOS and moves up all the other numbers.

Tb exchange the top 2 numbers we have .

DUP duplicates the TOS into NOS, pushing down all the other numbers.

ROT rotates the top 3 numbers.

Cell \# 	initial 	Ops->	DROP 	SWAP	ROT		DUP
0		-16		Result	73		73		5		16
1		73		->		5		-16		-16
2		5				2		5		73
3		2				...		2		2
4		...				...		...		...

Table 2-2 Stack manipulation operators

These actions are shown on page 19 above in Thble 2—2 (we show what each word does to the initial stack).

In addition the words OVER, UNDER, PICK and ROLL act as shown in Table 2-3 below (note PICK and ROLL must be

Cell \# 	initial		Ops->	OVER	UNDER	4 PICK	4 ROLL
0 		-16		 Result 	73 		-16		2
1 		73 		-> 		-16		73		-16
2 		5 				73 		-16		73
3 		2				5 		5		5
4 		...				2		2		2		...

Table 2-3 More stack manipulation operators

preceded by an integer that says where on the stack an element gets  \textbf{PlCK}ed or  \textbf{ROLL}ed).

Clearly, 1 PICK is the same as DUP, 2 PICK is a synonym for OVER, 2 ROLL means SWAP, and 3 ROLL means ROT.

As Brodie has noted (TF), it is rarely advisable to have aword use a stack so deep that PICK or ROLL is needed. It is generally better to keep word definitions short, using only a small number of arguments on the stack and consuming them to the extent possible. On the other hand, \textbf{ROT} and its opposite, \textbf{-ROT}\footnote{defined as : -ROT ROT ROT ;}, are often useful.

\subsection{The return stack and Its uses}

We have remarked above in §2§§2 that compilation establishes links from the calling word to the previously- defined word being invoked. Part of the linkage mechanism ——during actual execution- is the return stack (rstack): the address of the next word to be invoked after the currently executing word is placed on the rstack, so that when the current word is done, the system jumps to the next word. Although it might seem logical to call the address on the rstack the next address, it is actually called the return address for historical reasons.

In addition to serving as a reservoir of return addresses (since words can be nested, the return addresses need a stack to be put on) the rstack is where the limits of a DO LOOP construct are placed\footnote{We discuss looping in 2.7 below.}

The user can also store/retrieve to/from the rstack This is an example of using a component for a purpose other than the one it was designed for. Such use is not encouraged by every FORTH text, needless to say, since it introduces the spice of danger. To store to the rstack we say > R, and to retrieve we say R > . DUP > R is a speedup of the phrase DUP > R . The words D>R DR> , for maving double-length integers, also exist on many systems. The word R@ copies the top of the rstack to the TOS.

The danger is this: anything put on the rstack during a word’s execution must be removed before the word terminates. If the > R and the R > do not balance, then a wrong next address will be jumped to and EXECUTEd. Since this could be the address of data, and since it is being interpreted as machine instructions, the results will be always unpredictable, but seldom amusing.

Why would we want to use the rstack for storage when we have a perfectly good parameter stack to play with? Sometimes it becomes simply impossible to read code that performs complex gymnastics on the parameter stack, even though FORTH permits such gymnastics.

Consider a problem — say, drawing a line on a bit- mapped graphics output device from (x,y) to (x’,y’)— that requires 4 arguments. We have to turn on the appropriate pixels in the memory area representing the display, in the ranges from the origin to the end coordinates of the line. Suppose we want to work with x and y first, but they are 3rd and 4th on the stack. So we have to ROLL or PICK to get them to TOS where they can be worked with conveniently. We probably need them again, so we use

4PICK 4PICK ( -- x y x' y' x y)

Now 6 arguments are on the stack! See what I mean? A better way stores temporarily the arguments x’ and y', leaving only 2 on the stack. If we need to duplicate them, we can do it with an already existing word, DDUP.

Complex stack manipulations can be avoided by defining VARIABLEs —named locations— to store numbers. Since FORTH, variables are typically global — any word can access them — their use can lead to unfortunate and unexpected interactions among parts of a large program. Variables should be used sparingly.

While FORTH permits us to make variables local to the sub- if routines that use themlo, for many purposes the rstack can advantageously replace local variables:

\begin{itemize}
	\item The rstack already exists, so it need not be defined anew.
	\item When the numbers placed on it are removed, the rstack shrinks, thereby reclaiming some memory.
\end{itemize}

Suppose, in the previous example, we had put x’ and y’ on the rstack via the phrase

>R >R DDUP.

Then we could duplicate and access x and y with no trouble.

10. See FTR, p. 3253 for a description of beheading - a process to make variables local to a small \ set of subroutines. Another technique is to embed variables within a data structure so they cannot be referenccd inadvertently. Chapters 2§8§§3-2, 3§5§§2, 5§1§§2 and 11§2 offer examples. It

\underline{\textbf{A note of caution}}: since the rstack is a critical component of the execution mechanism, we mess with it at our peril. If we want to use it, we must clean up when we are done, so it is in the same state as when we found it. A word that places a number on the rstack must get it off again — using R> or RDROP — before exiting that word". Similarly, since no LOOP uses the rstack also, for each >R in such a loop (after DO) there must be a corresponding R > or RDROP (before LOOP is reached). Otherwise the results will be unpredictable and probably will crash the system.

\section{F\textit{etc}hing and storing}

Ordinary (16-bit) numbers are f\textit{etc}hed from memory to the stack by " @ " ("f\textit{etc}h"), and stored by " I " ("store"). The word @ expects an address on the stack and replaces that address by its contents using, \textit{e.g.}, the phrase X @ . The word " I" expects a number (NOS) and an address (T OS) to store it in, and places the number in the memory location referred to by the address, consuming both arguments in the process, as in the phrase 32 X !

Double length (32-bit) numbers can similarly be f\textit{etc}hed and stored, by D@ and DI . (FORTH systems designed for the newer 32-bit machines sometimes use a 32-bit-wide stack and may not distinguish between single- and double-length integers.)

Positive numbers smaller than 255 can be placed in single bytes of memory using C@ and CI . This is convenient for operations with strings of ASCII text, for example screen, file and keyboard I/O.

In Chapters 3, 4, S and 7 we shall extend the lexicon of @ and ! words to include floating point and complex numbers.

11. \textbf{RDROP} is a handy way to exit from a word before reaching the final ";". See TF.

\section{Arlthmetlc operations}

The 1979 or 1983 standards, not to mention the forthcoming ANSII standard, require that a conforming FORTH system contain a certain minimum set of predefined words. These consist of arithmetic operators + — * / MOD [MOD '/ for (usually) 16-bit signed-integer (-32767 to +32767) arithmetic, and equivalents for unsigned (0 to 65535), double-length and mixed-mode (16- mixed with 32-bit) arithmetic. The list will be found in the glossary accompanying your system, as well as in SF and F111.

\section{Comparing and testlng}

n addition to arithmetic, FORTH lets us compare numbers on the stack, using relational operators > < = .These operators work as follows: the phrase
2 3 > < cr > ok

will leave 0 ("false") on the stack, because 2 (N05) is not greater
than 3 (T OS). Conversely, the phrase

23 < <cr> ok

will leave-1 ("true") because 2 is less than 3. Relational operators typically consume their arguments and leave a "ﬂag" to show what happened\footnote{ The original FORTH-79 used + 1 for "true", 0 for "false"; many newer system that mostly follow FORTH-79 use -1 for "true". HS/FORTH is one such. Both FORTH-83 and ANSII FORTH require -1 for "true", 0 for "false".}. Those listed so far work with signed 16-bit integers. The operator \textbf{U<} tests unsigned 16-bit integers (0—65535).

FORTH offers unary relational operators 0 = 0 > and 0 < that determine whether the TOS contains a (signed) 16-bit integer that is 0, positive or negative. Most FORTHs offer equivalent relational operators for use with double-length integers.

The relational words are used for branching and control. The usual form is

:MAYBE 0> IF WORDl WORDZ
WORDn THEN ;

12.

The word \textbf{MAYBE} expects a number on the stack, and executes the words between \textbf{IF} and \textbf{THEN} if the number on the stack is positive, but not otherwise. If the number initially on the stack were negative or zero, \textbf{MAYBE} would do nothing.

An alternate form including \textbf{ELSE} allows two mutually exclusive actions:

:CHOOSE 0> IF WORD1 . . . WOHDn
ELSE WORDt' . . . WORDn'
THEN ; (n - - )

If the number on the stack is positive, \textbf{CHOOSE} executes \textbf{WORD1 WORD2... WORD}, whereas if the number is negative or 0, \textbf{CHOOSE} executes \textbf{WORD1' WORDn'} .

In either example, \textbf{THEN} marks the end of the branch, rather than having its usual logical meaning\footnote{This has led some FORTH gurus to prefer the synonymous word ENDIF as clearer than THEN.}.

\section{Looping and structured programming}

FORTH contains words for setting up loops that can be definite or indefinite:

BEGIN xxx ﬂag UNTIL

The words represented by xxx are executed, leaving the TOS (ﬂag) set to 0 (F) —at which point UNTIL leaves the loop — or -1 (T) —at which point \textbf{UNTIL} makes the loop repeat from \textbf{BEGIN}.

A variant is

BEGIN xxx ﬂag WHILE yyy REPEAT

Herc xxx is executed, WHILE tests the ﬂag and if it is 0 (F) leaves
the loop; whereas if flag is -1 (T) WHILE executes m and

\textbf{REPEAT} then branches back to \textbf{BEGIN}. These forms can be used to set up loops that repeat until some external event (pressing a key at the keyboard, \textit{\textit{e.g.}}) sets the ﬂag to exit the loop. They can also used to make endless loops (like the outer interpreter of FORTH) by forcing flag to be 0 in a definition like

:ENDLESS BEGIN )00( 0 UNTIL ;

FORTH also implements indexed loops using the words \textbf{DO LOOP +LOOP /LOOP}. These appear within definitions, \textit{\textit{e.g.}}

: LOOP-EXAMPLE 100 0 DO )OOt LOOP ;

The words xxx will be executed 100 times as the lower limit, 0, increases in unit steps to 99. To step by -2's, we use the phrase

-2 + LOOP

to replace \textbf{LOOP}, as in

: DOWN-BY-2's O 100 DO xxx -2 +LOOP ;

The word \textbf{/LOOP} 1s a variant of \textbf{+LOOP} for working with unsigned limits\footnote{Signed 16-bit integers run from -32768 to +32767, unsigted from 0 to 65535. See FTR.} and increments (to permit the loop index to go up to 65535 1n 16-bit systems).

\section{The pearl of FORTH}

An unusual construct, \textbf{CREATE. .DOES>}, has been called ‘the pearl of FORTH" \footnote{Michael Ham, "Structured Programming", Dr. Dobb’slmmal adel‘m Tools, October, 1986.} This is more than poetic license.

\textbf{CREATE} is a component of the compiler that makes a new dictionary entry with a given name (the next name in the input stream) and has no other function.

\textbf{DOES>} assigns a specific run-time action to a newly \textbf{CREATE}d word (we shall see this in §2§§8-3 below).

\subsection{Dummy words}
Sometimes we use \textbf{CREATE} to make a dummy entry that we can later assign to some action:

CREATE DUMMY
CA' * DefinES DUMMY

The second line translates as ``The code address of * defines \textbf{DUMMY}". Entry of the above phrase would let \textbf{DUMMY} perform the job of * just by saying \textbf{DUMMY}. That is, FORTH lets us first define a dummy word, and then give it any other word’s meaning \footnote{This usage is a non-standard construct of HS/FORTH.}.

Here is one use of this power: Suppose we have to define two words that are alike except for some piece in the middle:
\begin{lstlisting}
: *WORD  WORD1 WORD2 *  WORD3 WORD4 ;
: */WORD WORD1 WORD2 */ WORD3 WORD4 ;
\end{lstlisting}

we could get away with 1 word, together with \textbf{DUMMY} fromabove,

\begin{lstlisting}
: *_or_*/WORD
    WORD1 WORD2
    DUMMY
    WORD3 WORD4 ;
\end{lstlisting}
by saying
\begin{lstlisting}
CA' * DefinES DUMMY *_or_*/WORD
\end{lstlisting}

or
\begin{lstlisting}
CA' */ DefinES DUMMY *_or_*/WORD .
\end{lstlisting}

This technique, a rudimentary example of vector-lug, saves memory and saves programming time by letting us vary something in the middle of a definition \textit{after the definition has been entered in the dictionary}. However, this techniqlue must be used with caution as it is akin to self-modifying code\footnote{Self-modifying machine code is considered a serious "no-no" by modern structured programming standards. Although it is sometimes valuable, few modern cpu's are capable of handling it safely. More often, because cpu's tend to use pipelining and parallelism to achieve speed, a piece of code might be modified in memory, but — having been pre-f\textit{etc}hed before modification — actually execute in unmodified form.}


A similar procedure lets a subroutine call itself recursively, an enormous help in coding certain algorithms.

\subsection{Deﬂnlng "defining" words}

The title of this section is neither a typo nor a stutter: \textbf{CREATE} finds its most important use in extending the powerful class of FORTH words called "defining" words. The colon compiler ":" is such a word, as are VARIABLE and CONSTANT. The definition of VARIABLE is simple

\begin{lstlisting}
:VARIABLE CREATE 2 ALLOT ;
\end{lstlisting}

Here is how we use it:
\begin{lstlisting}
VARIABLE X <cr> ok
\end{lstlisting}

The inner workings of VARIABLE are these:
\begin{itemize}
    \item CREATE makes a dictionary entry with the next name in the input stream — in this case, X.
    \item Then the number 2 is placed on the stack, and the word ALLOT increments the pointer that represents the current location in the dictionary by 2 bytes.
    \item This leaves a 2- e vacancy to store the value of the variable (that is, the next ictionary header begins 2 bytes above the end of the one just defined).
\end{itemize}

When the outer interpreter loop encounters a new VARIABLE's name in the input stream, that name’s address is placed on the stack. But this is also the location where the 2 bytes of storage begins. Hence when we type in X, the TOS will contain the storage address named X.

As noted in §2.4 above, the phrase X @ (pronounced "X f\textit{etc}h") places the contents of address X on the stack, dropping the address in the process. Conversely, to store a value in the named location X, we use ! ("store"): thus
\begin{lstlisting}
4 X ! <cr> ok
X @ . <cr> ok
\end{lstlisting}

Double-length variables are defined via DVARIABLE, whose definition is

\begin{lstlisting}
2 DVARIABLE CREATE 4 ALLOT ;
\end{lstlisting}

FORTH has a method for defining words initialized to contain specific values: for example, we might want to define the number 17 to be a word. CREATE and "," ("comma") let us do this as follows:

\begin{lstlisting}
17 CREATE SEVENTEEN , <cr> ok
\end{lstlisting}

Now test it \textit{via}

\begin{lstlisting}
SEVENTEEN @ . <cr> 17 ok
\end{lstlisting}

\underline{\textbf{Note}}: The word "," ("comma") puts TOS into the next 2 bytes of the dictionary and increments the dictionary pointer by 2.

A word C, ("see-comma") puts a byte-value into the next byte of the dictionary and increments the pointer by 1 byte.

\subsection{Run-time vs. compile-time actions}

In the preceding example, we were able to initialize the variable SEVENTEEN to 17 when we CREATEd it, but we still have to fetch it to the stack via SEVENTEEN @ whenever we want it. This is not quite what we had in mind: we would like to find 17 in T0S when we say SEVENTEEN. The word DOES> gives us precisely the tool to do this.

As noted above, the function of DOES> is to specify a run-time action for the "child" words of a defining word. Consider the defining word CONSTANT, defined in high-level\footnote{Of course CONSTANT is usually a machine—code primitive, for speed.} FORTH by

\begin{lstlisting}
: CONSTANT CREATE , DOES> @ ;
\end{lstlisting}
and used as
\begin{lstlisting}
53 CONSTANT PRIME ok
\end{lstlisting}

Now test it:
\begin{lstlisting}
PRIME . <cr> 53 ok
\end{lstlisting}

What happened?
\begin{itemize}
    \item CREATE (hidden in CONSTANT) made an entry (named PRIME , the first word in the input stream following CONSTANT). Then "," placed the TOS (the number 53) in the next two bytes of the dictionary.
    \item DOES> (inside CONSTANT) then appended the actions of all words between it and ";" (the end of the definition of CONSTANT) to the child word(s) defined by CONSTANT.
    \item In this case, the only word between DOES> and ; was @ , so all FORTH constants defined by CONSTANT perform the action of placing their address on the stack (anything made by CREATE does this) and fetching the contents of this address.
\end{itemize}

\subsubsection{Klingons}
Let us make a more complex example. Suppose we had previously defined a word BOX ( n x y - - ) that draws a small square box of n pixels to a side centered at (x, y) on the graphics display. We could use this to indicate the instantaneous location of a moving object -— say a Klingon space-ship in a space-war game.

So we define a defining word that creates (not very realistic looking) space ships as squares n pixels on a side:

\begin{lstlisting}
: SPACE-SHIP CREATE . DOES>
@-ROT (--nxy) BOX;
: SIZE ; \ do-nothing word
\end{lstlisting}

Now, the usage would be (SIZE is included merely as a reminder of what 5 means — it has no function other than to make the definition look like an English phrase)

\begin{lstlisting}
SIZE 5 SPACE-SHIP KLINGON <cr> ok
7135 KLINGON <cr> ok
\end{lstlisting}

Of course, SPACE-SHIP is a poorly constructed defining word because it does not do what it is intended to do. Its child-word KLINGON simply draws itself at (x, y).

What we really want is for KLINGON to undraw itself from its old location, compute its new position according to a set of rules, and then redraw itself at its new position This sequence of operations would require a definition more like

\begin{lstlisting}
:OLD.POS@ (adr--adr n x y) DUP @ OVER
  2+ D@ :
: SPACE-SHIP CREATE , 4 ALLOT DOES>
   OLD.POS@ UNBOX NEW.POSI
   OLD.POS@ BOX DROP ;
\end{lstlisting}

where the needed specialized operation UNBOX would be defined previously along with BOX.

\subsubsection{Dimensioned data (with Intrinsic unlts)}
Here is another example of the power of defining words and of the distinction between compile-time and run-time behaviors.

Physical problems generally work with quantities that have dimensions, usually expressed as mass (M), length (L) and time (T) or products of powers of these. Sometimes there is more than one system of units in common use to describe the same phenomena.

For example, traffic police reporting accidents in the United States or the United Kingdom might use inches, feet and yards; whereas Continental police would use the metric system. Rather than write different versions of an accident analysis program it is simpler to write one program and make unit conversions part of the grammar. This is easy in FORTH; impossible in FORTRAN, BASIC Pascal or C; and possible, but exceedingly cumbersomein Ada\footnote{An example (and its justification) of dimensioned data types in Ada is given by Do-While l ones, \textit{Dr. Dobb's Journal}, March 1987. The FORTH solution below is much simpler than the Ada version.}.

We simply keep) all internal lengths in millimeters, say, and con-
vert as follow\footnote{This example is based on 16-bit integer arithmetic. The word */ means "multiply the third number on the stack by NOS, keeping 32 bits of precision, and divide by TOS". That is, the stack comment for */is(a b c --a*b/c).}:

\begin{lstlisting}
: INCHES  254 10 */ ;
: FEET  [ 254 12 * ] LITERAL 10 */ ;
: YARDS [ 254 36 * ] LITERAL 10 */ ;
: CENTIMETERS 10 * ;
: METERS 1000 * ;
\end{lstlisting}

The usage would be
\begin{lstlisting}
10 FEET . <cr> 3048 ok
\end{lstlisting}

These are more definitions than necessary, of course, and the technique generates unnecessary code. A more compact approach uses a \textit{defining word}, UNITS:

\begin{lstlisting}
: D, SWAP , , ; \ I double—length # in next ceIIs
: UNITS CREATE D, DOES> D@ */ ;
\end{lstlisting}

Then we could make the table
\begin{lstlisting}
254 10        UNITS INCHES
254 12 * 10   UNITS FEET
254 36 * 10   UNITS YARDS
 10  1        UNITS CENTIMETERS
1000 1        UNITS METERS
\ Usage:
\ 10 FEET . <cr> 3048 ok
\ 3  METERS . <cr> 3000 ok
\ ......
\ \textit{etc}.
\end{lstlisting}

This is an improvement, but FORTH lets us do even better: here is a simple extension that allows conversion back to the input units, for use in output:

\begin{lstlisting}
VARIABLE <AS>                \ new variable
0 <AS> !                     \ initialize to "F"
: AS -1 <AS> ! ;             \ set <AS> = "T"
: UNITS CREATE D, DOES>
   D@                        \ get 2 #s
   <AS> @                    \ get current val.
      IF SWAP THEN           \ flip if "true"
  */  0 <AS> ! ;             \ convert. reset <AS>

BEHEAD' < AS >       \ make it local for security(*@\footnote{Headerless words are described in "R, p. 3251f. The word BEHEAD' is HS/FORTH’s method for making a normal word into a headerless one. See Ch. 5§1§§3 for further details.} @*)
\ unit definitions remain the same
\ Usage:
\ 10 FEET       . <cr> 3048 ok
\ 3048 AS FEET  . <cr> 10 ok
\end{lstlisting}

\subsection{Advanced methods of controlllng the compiler}
FORTH includes a technique for switching from compile mode to interpret mode while compiling or interpreting. This is done using the words ] and [ . (Contrary to intuition, ] turns the
compiler on, [ turns it off.)

One use of ] and [ is to create an "action table" that allows us to choose which of several actions we would like to perform\footnote{Better methods will be described in Chapter 5.}.

For example, suppose we have a series of push-buttons numbered 1-6, and a word WHAT to read them.

That is, WHAT waits for input from a keypad; when button \#3 is pushed, \textit{e.g.}, WHAT leaves 3 on the stack.

We would like to use the word \lstinline$BUTTON$ in the following way:

\begin{lstlisting}
WHAT BUTTON
\end{lstlisting}

BUTTON can be defined to choose its action from a table of
actions called BUTTONS . We define the words as follows:

\begin{lstlisting}
CREATE BUTTONS ] RING-BELL OPEN-DOOR
  ENTER LAUGH CRY SELF-DESTRUCT [
: BUTTON 1- 2* BUTTONS + @ EXECUTE ;
\end{lstlisting}

If, as before, I push \#3, then the action ENTER will be executed. Presumably button \#7 is a good one to avoid\footnote{The safety of an execution table can be increased by making the first (that is, the zero’th) action WARNING, and making the first step of BUTTON a word CHECK-DATA that maps any number not in the range 1-6 into 0. Then a wrong button number causes a WARNING to be issued and the system resets.}.

How does this work?
\begin{itemize}
    \item CREATE BUTTONS makes a dictionary entry BUTTONS.
    \item ] turns on the compiler: the previously-defined word-names RING-BELL, \textit{etc}. are looked up in the dictionary and compiled into the table (as though we had begun with :), rather than being executed.
    \item \rbrack returns to interactive mode (as if it were ;), so that the next colon definition (BUTTON) can be processed.
    \item The table BUTTONS now contains the code-field addresses (CFA’s) of the desired actions of BUTTON.
    \item BUTTON first uses 1- to subtract 1 from the button number left on the stack by WHAT (so we can use 0—based numbering into the table — if the first button were \# 0, this would be unneeded).
    \item 2* then multiplies by 2 to get the offset (from the beginning of BUTTONS) of the CFA representing the desired action.
    \item BUTTONS + then adds the base address of BUTTONS to get the absolute address where the desired CPA is stored.
    \item @ fetches the CFA for EXECUTE to execute.
    \item EXECUTE executes the word corresponding to the button pushed. Simple!
\end{itemize}

You may well ask "Why bother with all this indirection, pointers, pointers to pointers, tables of pointers to tables of pointers, and the like?" Why not just have nested IF...ELSE...THEN constructs, as in Pascal?

There are three excellent reasons for using pointers:
\begin{itemize}
    \item Nested IF...THEN’s uickly become cumbersome and difficult to decipher (TF). ey are also \underline{\textbf{slow}} (see Ch. 11).
    \item Changing pointers is generally much faster than changing other kinds of data — for example reading in code overlays to accomplish a similar task.
    \item The unlimited depth of indirection possible in FORTH permits arbitrary levels of abstraction. This makes the computer behave more "intelligently" than might be possible with more restrictive languages.
\end{itemize}

A similar facility with pointers gives the C language its abstractive power, and is a major factor in its popularity.

\subsection{Strings}
By now it should be apparent that FORTH can do anything any other language can do. One feature we need in any sort of programming —scientific or otherwise — is the ability to handle alphanumeric strings. We frequently want to print messages to the console, or to put captions on figures, even if we have no interest in major text processing.

While every FORTH system must include words to handle strings(see, e.g., FTIL Ch. 9) —the very functioning of the outer interpreter, compiler, \textit{etc}., demands this — there is little unanimity in defining extensions. BASIC has particularly good string-handling features, so HS/FORTH and others provide extensions designed to mimic BASIC’s string functions.

Typical FORTH strings are Iimite to 255 characters because they
contain a count in their first byte . The word COUNT

:COUNT DUP 1+ SWAP C@ ; (adf--nadr+1)

expects the address of a counted string, and places the count and
the address of the first character of the string on the stack. TYPE,
a required ’79 or ’83 word, prints the string to the console.

It is straightforward to employ words that are part of the system
(such as KEY and EXPECT) to define a word like 3" that takes
all characters typed at the keyboard up to a final " (close-quote
—not a word but a string-terminator), makes a counted string of
them, and places the string in a buffer beginning at an address
returned by PAD".

The word 3. ("string-emit") could then be defined as
\begin{lstlisting}
: $. COUNT TYPE ; (adr - -)
and would be used with 3" like this:

$' The quick brown fox" < cr> ok
S. The quick brown fox ok
\end{lstlisting}

Since this book in not an attempt to paraphrase fiR it is strongly
recommended that the details of using the system words to devise
a string lexicon be studied there.

One might contemplate modifying the fiR lexicon by using a
full 16-bit cell for the count. This would permit strings of up to
64k bytes (using unsigned integers"), wasting 1 byte of memory
per short ( 255 bytes) string. Although few scientific applications
need to manipulate such long strings, the program that generated
the index-to this book needed to read a page at a time, and thus
to handle strings about 3—5 kbytes long.

 

24. A single byte can represent positive numbers 0-255.
25. A system variable that returns the current starting address of the "scratchpad".

26. ma. 3.

38 Chapter 2 — Programming In FORTH Scientific Forth

§10 FORTH programming style
A FORTH program typically looks like this

\begin{lstlisting}
\ Example of FORTH program
:WORD1 .. . ;

:WORD2 OTHER-WORDS ;
:WORDS YET-OTHER-WORDS ;

: LAST-WORD wonon ...WORD3
wonoz wonm ;
LAST-WORD <cr> \ run program
\end{lstlisting}

Note: The word \ means "disregard the rest of this line". It is a
convenient method for commenting code.

In other words, a FORTH program consists of a series of word
definitions, culminating in a definition that invokes the whole
shebang. This aspect gives FORTH programming a somewhat
different ﬂavor from programming in more conventional lan-

guages.

Brodie notes in TF that high-level programming languages are
considered good if they require structured, top-down program-
ming, and wonderful if they impose information hiding. Languages
such as FORTRAN, BASIC and assembler that permit direct
jumps and do not impose structure, top-down design and data-
hiding are considered primitive or bad. To what extent does
FORTH follow the norms of good or wonderful programming
practice?

§§1 Structure
The philosophy of "structured programming" entered the
general consciousness in the early 1970’s. The idea was to
make the logic of program control flow immediately apparent,

O Jdian V.Nobie — All rights reserved.

arms-Warm 39

thereby aiding to produce correct and maintainable programs.
The language Pascal was invented to impose by fiat the discipline
of structure. To ti? end, direct jumps (GOT Os) were omitted
from the language .

FORTH programs are automatically structured because word
definitions are nothing but subroutine calls. The language con‘
tains no direct jump statements (that is, no GOT 0's) so it is
impossible to write "spaghetti" code.

A second aspect of structure that FORTH imposes (or at least
encourages) is short definitions. There is little speed penalty
incurred in breaking a long procedure into many small ones,
unlike more conventional languages. Each of the short words has
one entry and one exit point, and does one job. This is the beaux
ideal of structured programming!

"2 "Top-down" design

ost authors of "how to program" books recommend design-

ing the entire program from the general to the particular.
This is called "top-down" programming, and embodies these
steps:

a Make an outline, ﬂow chart, data-ﬂow diagram or whatever,
taking a broad overview of the whole problem.

a Break the problem into small pieces (decompose it).
0 Then code the individual components.

The natural programming mode in FORTH is "bottom-up"
rather than "top-down" — the most general word appears last,
whereas the definitions necessarily progress from the primitive
to the complex. It is possible - and sometimes vital — to invoke
a word before it is defined ("forward referencing’ ). The dic-
tionary and threaded compiler mechanisms make this nontrivial.

 

27. lronially, most programmers refuse to get along without spaghetti code, so commercial Pascal's
now include GOTO. Only FORTH among major languages completely eschews both line labels
and 6010;, making it the most structured language available.

28. The FORmula TRANsIator in Ch. 1154 uses this method to implement its recursive structure.

OWVNobIe-Aldghtsreaarved.

CMptar 2 - Programming In FORTH Scientific Forth

The naturalness of bottom-up programming encourages a some-
what different approach from more familiar languages:

0 In FORTH, components are specified roughly, and then 3 they
are coded they are immediately tested, debugged, redesigned
and improved.

0 The evolution of the components guides the evolution of the
outer levels of the program.

We will observe this evolutionary style in later chapters as we
design actual programs.

§§3 Information hiding
Information (or data) "hiding" is another doctrine of structured
programming. It holds that no subroutine should have access
to, or be able to alter (corruptlzg data that it does not absolutely
require for its own functioning .

Data hiding is used both to prevent unforeseen interactions
between pieces of a large program; and to ease designing and
debugging a large program. The program is broken into small,
manageable chunks ("black boxes") called modules or objects
that communicate by sending messages to each other, but are
otherwise mutually impenetrable. Information hiding and
modularization are now considered so important that special
languages —Ada, MODULA-Z, C+ + and Object Pascal— have
been devised with it in mind.

To illustrate the problem information hiding is intended to solve,
consider a FORTRAN program that calls a subroutine

 

Rather like the "cell" system in revolutionary conspiracies, where members of a cell know only
each other but not the members of other cells. Mechanisms for receiving and transmitting mes-
sages between cells are double-blind. Hence, if an individual is captured or is a spy, he can
betray at most his own cell and the damage is limited.

MZ-PWhFOfiTH ‘1

PROGRAM MAIN
some lines

CALL SUB1(arg1, ar92, , argn. mswer)
some lines

END

SUB1(X1, , Xn, Y)
some lines
Y = something
RETURN
END

There are two ways to pass the arguments from MAIN to SUBI,
and FORTRAN can use both methods.

0 Copy the arguments from where they are stored in MAIN into
locations in the address space of SUBl (set aside for them
during compilation). If the STATEMENTS change the values
X1,...,Xn during execution of SUBl, the original values in the
callin program will not be affected (because they are stored
elsew ere and were copied during the CALL).

0 Let SUBl have the addresses of the arguments where they are
stored in MAIN. This method is dangerous because if the
arguments are changed during execution of SUBl, they are
changed in MAIN and are forever corrupted. If these changes
were unintended, they can produce remarkable bugs.

Although copying arguments rather than addresses seems safer,
sometimes this is impossible either because the increased
memory overhead may be infeasible in problems with large
amounts of data, or because the extra overhead of subroutine calls
may unacceptably slow execution.

What has this to do with FORTH?

e FORTH uses linked lists of addresses, compiled into a diction-
ary to which all words have equal right of access.

0 Since everything in FORTH is a word —constants, variables,
numerical operations, I/O procedures- it might seem impos-
sible to hide information in the sense described above.

0 Fortunate] , word-names can be erased from the dictionary
after their F As have been compiled into words that call them.
(This erasure is called "beheadmg".)

emvm—Mmm.

42 Chapter 2 — Programmhg in FORTH Scientific Forth

e Erasing the names of variables arantees they can be neither
accessed nor corru ted by unaut orized words (except through
a calamity so drea ful the program crashes).

§§4 Documenting and commenting FORTH code
FORTH is sometimes accused of being a "write-only" language. In other words, some complain that FORTH is cryptic. I feel this is basically a complaint against poor documentation and unhelpful word names, as Brodie and others have noted.

Unreadability is equally a ﬂaw of poorly written FORTRAN, Pascal, C, \textit{et al}.

FORTH offers a programmer who takes the trouble a goodly
array of tools for adequately documenting code.

§§4—1 Parenthesized remarks
The word ( —a left parenthesis followed by a space - says "dis- ‘
regard all following text up until the next right parenthesis in
the input stream. Thus we can intersperse explanatory remarks
within colon definitions. This method was used to comment the
Legendre polynomial example program in Ch. 1.

§§4—2 Stack comments
A particular form of parenthesized remark describes the effect of
a word on the stack (or on the ﬂoating point fstack in Ch. 3). For
example, the stack-effect cement (stack comment, for short)

( adr - - n)
would be appropriate for the word @ ("f\textit{etc}h"): it says @ expects I

to find an address (adr) on the stack, and to leave its contents (n) .
upon completion.

The corresponding comment for i would be

 

30. The right parenthesis, ) , is not a word but a delimiter.

(nadr--).

An fstack comment is prefaced by a double colon :2 as

(::x--f[x]).

Note that to replace parentheses within the comment we use
brackets [ ] , since parentheses would be misinterpreted. Since
the brackets appear to the right of the word ( , they cannot be
(mis-) interpreted as the FORTH words ] or [ .

With some standard conventions for names", and standard ab-
breviations for different types of numbers, the stack comment
may be all the documentation needed, especially for a short word.

\subsubsection{Drop line (\textbackslash)}
The word \textbackslash (back-slash followed by space) has gained favor as a method for including longer comments. It simply means "drop everything in the input stream until the next carriage return". Instructions to the user, clarifications or usage examples are most naturally expressed in an included block of text with each line set off by \textbackslash .

\subsubsection{Self-documenting code}
By eliminating ungrammatical phrases like CALL or GOSUB,
FORTH presents the opportunity —via telegraphic names33 for
words — to make code almost as self-documenting and
transparent as a simple English or German sentence. Thus, for
example, a robot control program could contain a phrase like

2 TIMES LEFT EYE WINK

which is clear (although it sounds like a stage direction for Brunhilde to vamp Siegfried). It would even be possible without much

See, \textit{e.g.}, L Brodie, 11", Ch. 5, Appendix E.
Forthosefamiliarwithassemblylanguage, \textbackslash is exactly analogous to ; in assembler. But since ; is already used to cleseeoiondefinitionsinkaH, the symbol \textbackslash has been used in itspiace.

The matter of naming brings to mind Mark Twain's remark that the difference between the almost-right word and the right one is the difference between the lightning-bug and the lightning.

difficulty to define the words in the program so that the sequence could be made English-like:

WINK LEFT EYE 2 TIMES .

§§5 Salim

Some high level languages perform automatic bounds checking on arrays, or automatic type checking, thereby lending them a spurious air of reliability. FORTH has almost no error checking
of any sort, especially at run time. Nevertheless FORTH is a remarkably safe language since it fosters fine-grained decomposition into small, simple subroutines. And each subroutine can be checked as soon as it is defined. This combination of simplicity and immediacy can actually produce safer, more predictable code than languages like Ada, that are ostensibly designed for safety.

Nonetheless, error checking —especialiy array bounds-checking— can be a good idea during debugging. FORTH lets us include checks in an unobtrusive manner, by placing all the safety
mechanisms in a word or words that can be "vectored" in or out as desired".

 

34. See m for a more thorough discussion of vectoring. Brodie, TF, sugests a nice construct called DOER MAKE that can be used for graceful vectoring.