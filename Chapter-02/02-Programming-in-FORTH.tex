% 2 -- Programming in FORTH

\chapter{Programming in FORTH}

\TallC{This} chapter briefly reviews the main ideas of FORTH to let the reader understand the program fragments and subroutines that comprise the meat of this book. We make no pretense to complete coverage of standard FORTH programming methods. \textbf{Chapter 2 is not a programmer’s manual!}

Suppose the reader is stimulated to try FORTH - how can he proceed? Several excellent FORTH texts and references are available: \textit{Starting FORTH} \sepfootnote{02_01} and \textit{Thinking FORTH} \sepfootnote{02_02} by Leo Brodie; and \textit{ FORTH: a Text and Reference} \sepfootnote{02_03} by M.Kelly and N.Spies. I strongly recommend reading \FTR or \SF (or both) before trying to use the ideas from this book on a FORTH system. (Or at least read one concurrently.)

\TallC{The} (commercial) GEnie information network maintains a session devoted to FORTH under the aegis of the Forth Interest Group (fiG).

FIG publishes a journal \textit{Forth Dimensions} whose object is the exchange of programming ideas and clever tricks.

The Association for Computing Machinery (11 West 42nd St., New York, NY 10036) maintains a Special Interest Group on FORTH (SIGForth).

The Institute for Applied FORTH Research (Rochester, NY) publishes the refereed \textit{Journal of FORTH Application and Research}, that serves as a vehicle for more scholarly and theoretical papers dealing with FORTH.

Finally, an attempt to codify and standardize FORTH is underway, so by the time this book appears the first draft of an ANS FORTH and extensions may exist.

\section{The structure of FORTH}\label{chap:02_01}

\TallC{The} "atom" of FORTH is a \textbf{word} a previously-defined operation (defined in terms of machine code or other, previously-defined words) whose definition is stored in a series of linked lists called the \textbf{dictionary}. The FORTH operating system is an endless loop (outer interpreter) that reads the console and interprets the input stream, consulting the dictionary as necessary. If the stream contains a word\sepfootnote{02_04} in the dictionary the interpreter immediately executes that word.

\begin{figure}[ht]
    \framebox[\textwidth]{
        \begin{tikzpicture}[node distance=2cm]
            %Create nodes for left loop
            \node (input_1)     [wordinr1] {Input?}    ;
            \node (interpret_1) [wordinr1, right of = input_1, xshift=0.5cm, yshift=-0.75cm] {Interpret};
            \node (ok)          [wordinr1, below of = input_1, xshift=1.0cm, yshift=0.5cm] {ok};
            \coordinate[below of=input_1, yshift=0.5cm] (cont_1);
            \coordinate[left  of=cont_1,  xshift=0.5cm] (cont_2);
            \coordinate[above of=cont_2, yshift=0.5cm] (cont_3);
            \coordinate[above of=input_1, yshift=-1.0cm] (cont_4);
            \coordinate[below of=input_1, xshift=2.5cm, yshift=0.5cm] (cont_5);
            %Connect left loop
            \draw [arrow] (input_1.south) -- node[xshift=0.40cm] {No} (cont_1.north);
            \draw [arrow] (ok.west)       -- (cont_1.east);
            \draw [arrow] (cont_1.west)   -- (cont_2.east);
            \draw [arrow] (cont_2.north)  -- (cont_3.south);
            \draw [arrow] (cont_3.east)   -- (cont_4.west);
            \draw [arrow] (cont_4.south)  -- (input_1.north);
            %Connect right loop
            \draw [arrow] (input_1.east)  -| node[yshift=0.30cm, xshift=-0.80cm] {Yes} (interpret_1.north) ;
            \draw [arrow] (interpret_1.south) -- (cont_5.north);
            \draw [arrow] (cont_5.west) -- (ok.east) ;
            
            \node (interpret_2) [wordinr2, yshift=0.75cm, xshift=5.0cm]           {Interpret} ;
            \node (word)        [wordinr2, yshift=1.0cm,  below of = interpret_2] {word?}     ;
            \node (number_1)    [wordinr2, yshift=1.0cm,  below of = word, ]      {number?}   ;
            \node (error)       [wordinr2, yshift=1.0cm,  below of = number_1]    {ERROR}     ;
            \node (execute)     [wordinr2, xshift=1.0cm,  right of = word]        {EXECUTE}   ;
            \node (number_2)    [wordinr2, xshift=1.0cm,  right of = number_1]    {NUMBER}    ;
            \draw [arrow] (interpret_2) -- (word);
            \draw [arrow] (word)        -- (number_1);
            \draw [arrow] (number_1)    -- (error);
            \draw [arrow] (word)        -- node[yshift=0.30cm] {Yes} (execute);
            \draw [arrow] (number_1)    -- node[yshift=0.30cm] {Yes} (number_2);
        \end{tikzpicture}
    }
  \caption{\textit{Overview of FORTH outer interpreter}}
  \label{fig:02_01}
\end{figure}

In general, because FORTH is interpretive as well as compiled, the best way to study something new is in front of a computer running FORTH. Therefore we explain with illustrations, expecting the reader to try them out.

In what follows, anything the user types in will be set in \lstinline$Helvetica$, such as \regc{DECIMAL} below.

Machine responses appear in ordinary type.

We now give a trivial illustration:

\begin{lstlisting}
    DECIMAL <cr> ok
\end{lstlisting}

\Note \textbf{\underline{s:}}
\begin{itemize}
  \item \bc{<cr>} means "the user pushes the ENTER or $\Leftarrow$ button".
  \item \bc{ok} is what FORTH says in response to an input line, if nothing has gone wrong.
  \item \regc{DECIMAL} is an instruction to use base 10 arithmetic. FORTH will use any base on tell it, within reason, but usually only \regc{DECIMAL} and \regc{HEX} (hexadecimal) are predefined.
\end{itemize}

When the outer interpreter (see Fig. \ref{fig:02_01}, p. \pageref{fig:02_01}) encounters text with no dictionary entry, it tries to interpret it as a \bc{NUMBER}.

It places the number in a special memory location called "the top of the stack" (TOS)\sepfootnote{02_05}
\begin{lstlisting}
    2 17 +. <cr> 19 ok
\end{lstlisting}

\Note \textbf{\underline{s:}}
\begin{itemize}
  \item FORTH interprets 2 and 17 as numbers, and pushes them onto the stack. "\bc{+}" is a word and so is "\bc{.}" so they are \bc{EXECUTE}d.
  \item \bc{+} adds 2 to 17 and leaves 19 on the stack.
  \item The word \bc{.} (called "emit") removes 19 from the stack and displays it on the screen.
\end{itemize}

We might also have said\sepfootnote{02_06}

\begin{lstlisting}
    HEX 0A 14 * . <cr> C8 ok
\end{lstlisting}

(Do you understand this? Hint: \bc{HEX} stands for "switch to hexadecimal arithmetic")

If the incoming text can neither be located in the dictionary nor interpreted as a number, FORTH issues an error message.


\section{Extending the dictionary}

\TallC{The} compiler is one of FORTH's most endearing features. It is elegant, simple, and mostly written in FORTH. Although the technical details of the FORTH compiler are generally more interesting to systems developers than to scientists, its components can often be used to solve programming problems. When this is the case, we necessarily discuss details of the compiler. In this section we discuss how the compiler extends the dictionary. In \S2\S\S8 below we examine the parts of the compiler in greater detail.

FORTH has special words that allow the creation of new dictionary entries, \ie, new words. The most important are "\bc{:}" ("start a new definition") and "\bc{;}" ("end the new definition").

Consider the phrase

\begin{lstlisting}
    : NEW-WORD WORD1 17 WORDZ . . . WORDn ; ok
\end{lstlisting}

The initial "\bc{:}" is \bc{EXECUTE}d because it is already in the dictionary. Upon execution, "\bc{:}" does the following:

\begin{itemize}
    \item Creates a new dictionary entry, \bc{NEW-WORD}, and switches from \textbf{interpret}- to \textbf{compile} mode.
    \item In compile mode, the interpreter looks up words and --rather than executin them-- installs ointers to their code. If the text is a number (\bc{17} above), FORTH builds the literal number into the dictionary space allotted for \bc{NEW-WORD}.
    \item The action of \bc{NEW-WORD} will be to \bc{EXECUTE} sequentially the previously-defined words \bc{WORD1}, \bc{WORD2}, ...\bc{WORDn}, placing any built-in numbers on the stack as they occur.
    \item The FORTH compiler \bc{EXECUTE}s the last word "\bc{;}" of the definition, by installing code (to return control to the next outer level of the interpreter\sepfootnote{02_07}) then switching back from compile to interpret mode. Most other languages treat tokens like "\bc{;}" as flags (in the input stream) that \textit{trigger} actions, rather than actions in their own right FORTH lets components execute themselves.
\end{itemize}

In FORTH \textit{all} subroutines are words that are invoked when they are named. No explicit CALL or GOSUB statement is required.

The above definition of \textbf{NEW-WORD} is extremely structured compared with FORTRAN or BASIC. Its definition is just a series of subroutine calls.

\TallC{We} now illustrate how to define and use a new word using the previously defined words "\bc{:}"and "\bc{;}". Enter the phrase (this new word \bc{*+} expects 3 numbers, \textit{a}, \textit{b}, and \textit{c} on the stack)

\begin{lstlisting}
    : *+   * + ; ok
\end{lstlisting}

\Note \underline{\textbf{s:}}
\begin{itemize}
    \item \bc{*} multiplies \verb|b| with \verb|c|, leaving \verb|b*c|.
    \item \bc{+} then adds \verb|b*c| to \verb|a|, leaving \verb|a + b*c| behind.
\end{itemize}

Now we actually try out \bc{*+} :

\begin{lstlisting}
    DECIMAL 5 6 7 *+ . 47 ok
\end{lstlisting}

\Note \underline{\textbf{s:}}
\begin{itemize}
    \item The period \bc{.} is not a typo, it EMITs the result.
    \item FORTH's response to \bc{a b c *+ .} is \bc{a + b*c ok}.
\end{itemize}

What if we were to enter \bc{*+} with nothing on the stack? Let's try it and see (\bc{.S} is a word that displays the stack without changing its contents):

\begin{lstlisting}
    .S empty stack ok

    *+ empty stack ok
\end{lstlisting}

\dotrule{1\textwidth}

\underline{\textbf{Exercise:}}

Suppose you entered the input line

\begin{lstlisting}
    HEX 5 6 7 *+ . <cr> xxx ok
\end{lstlisting}

What would you expect the response \textbf{xxx} to be?

\textit{Answer:} \bc{2F}

\dotrule{1\textwidth}

\section{Stacks and reverse Polish notation (RPN)}
\TallC{We} now discuss the stack and the "reverse Polish" or "postfix" arithmetic based on it. (Anyone who has used one of the Hewlett-Packard calculators should already be familiar with the basic concepts.)

A Polish mathematician (J .Lukasewcleia) showed that numerical calculations require an irreducible minimum of elementary operations (fetching and storing numbers as well as addition, subtraction, multiplication and division). The minimum is obtained when the calculation is organized by "stack" arithmetic.

Thus virtually all central processors (CPU's) intended for arithmetic operations are designed around stacks. FORTH makes efficient use of CPU's by reflecting this underlying stack architecture in its syntax, rather than translating algebraic-looking program statements ("infix" notation) into RPN-based machine operations as FORTRAN, BASIC, C and Pascal do.

But what \textit{is} a stack? As the name implies, a stack is the machine analog of a pile of cards with numbers written on them. Numbers are always added to, and removed from, the top of the pile. (That is, a stack resembles a job where layoffs follow seniority: last in, first out.) Thus, the FORTH input line

\begin{lstlisting}
    DECIMAL 2 5 73 -16 ok
\end{lstlisting}

followed by the line

\begin{lstlisting}
    + - * . yyy ok
\end{lstlisting}
leaves the stack in the successive states shown in Table \ref{tab:02_01} below

\begin{table}
    \begin{center}
        \begin{tabular}{|c c c c c c c|}
            \hline
       Cell\# & Initial    & Ops$\rightarrow$ & +       & -          & *       & . \\ 
            \hline
            0 & \lgray -16 & Result        & \Aggray 57 & \dgray -52 & \gray 104 & ... \\ 
            1 & \lgray 73  & $\rightarrow$ & \Aggray 5  & \dgray 2   & ...       & ... \\
            2 & \lgray 5   &               & \Aggray 2  & ...        & ...       & ... \\
            3 & \lgray 2   &               & ...        & ...        & ...       & ... \\
            \hline
        \end{tabular}
    \end{center}
    \caption{\textit{Picture of the stack during operations}}
    \label{tab:02_01}
\end{table}

We usually employ zero-based relative numbering in FORTH data structures --stacks, arrays, tables, \etc-- so TOS ("top of stack") is given relative \#0, NOS ("next on stack") \#1, \etc

The operation "\bc{.}" ("emit") displays -104 to the screen, leaving the stack empty. That is, \bc{yyy} above is \bc{-104}.

\subsection{Manipulating the parameter stack}

\TallC{FORTH} system incorporate (at least) two stacks: the \textbf{parameter stack} which we now discuss, and the \textbf{return stack} which we defer to \S2.3.2.

In order to use a stack-based system, we must be able to put numbers on the stack, remove them, and rearrange their order. FORTH includes standard words for this purpose.

Putting numbers on the stack is easy: one simply types the number (or it appears in the definition of a FORTH word).

To remove a number we have the word \bc{DROP} that drops the number from TOS and moves up all the other numbers.

To exchange the top 2 numbers we have .

\bc{DUP} duplicates the TOS into NOS, pushing down all the other numbers.

\bc{ROT} rotates the top 3 numbers.

\begin{table}
    \begin{center}
        \begin{tabular}{|c c c c c c c|}
            \hline
       \textbf{Cell\#} & Initial    & \textbf{Ops$\rightarrow$} & \textbf{DROP}   & \textbf{SWAP}        & \textbf{ROT}       & \textbf{DUP}\\  
            \hline
            0 & \lgray -16 & \textbf{Result}        & \Aggray 73 & \dgray 73  & \gray 5   & \digray -16 \\ 
            1 & \lgray 73  & \textbf{$\rightarrow$} & \Aggray 5  & \dgray -16 & \gray -16 & \digray -16 \\
            2 & \lgray 5   &               & \Aggray 2  & \dgray 5   & \gray 73  & \digray 73  \\
            3 & \lgray 2   &               & ...        & \dgray 2   & \gray 2   & \digray 5   \\
            4 & \lgray ... &               & ...        & ...        & ...       & \digray 2   \\
            \hline
        \end{tabular}
    \end{center}
    \caption{\textit{Stack manipulation operators}}
    \label{tab:02_02}
\end{table}

These actions are shown on page \pageref{tab:02_02} above in Table \ref{tab:02_02} (we show what each word does to the initial stack).

In addition the words \bc{OVER}, \bc{UNDER}, \bc{PICK} and \bc{ROLL} act as shown in Table \ref{tab:02_03} below (note \bc{PICK} and \bc{ROLL} must be preceded by an integer that says where on the stack an element gets  \bc{PICK}ed or \bc{ROLL}ed).

\begin{table}
    \begin{center}
        \begin{tabular}{|c c c c c c c|}
            \hline
       \textbf{Cell\#} & Initial    & \textbf{Ops$\rightarrow$} & \textbf{OVER}   & \textbf{UNDER}        & \textbf{4 PICK}  & \textbf{4 ROLL}\\ [0.5ex] 
            \hline
            0 & \lgray -16 & \textbf{Result}        & \Aggray 73  & \dgray -16 & \gray 2   & \digray 2   \\ 
            1 & \lgray 73  & \textbf{$\rightarrow$} & \Aggray -16 & \dgray 73  & \gray -16 & \digray -16 \\
            2 & \lgray 5   &               & \Aggray 73  & \dgray -16 & \gray 73  & \digray 73  \\
            3 & \lgray 2   &               & \Aggray 5   & \dgray 5   & \gray 5   & \digray 5   \\
            4 & \lgray ... &               & \Aggray 2   & \dgray 2   & \gray 2   & ...         \\
            \hline
        \end{tabular}
    \end{center}
    \caption{\textit{More stack manipulation operators}}
    \label{tab:02_03}
\end{table}

Clearly, \bc{1 PICK} is the same as \bc{DUP}, \bc{2 PICK} is a synonym for \bc{OVER}, \bc{2 ROLL} means \bc{SWAP}, and \bc{3 ROLL} means \bc{ROT}.

As Brodie has noted (\TF), it is rarely advisable to have aword use a stack so deep that \bc{PICK} or \bc{ROLL} is needed. It is generally better to keep word definitions short, using only a small number of arguments on the stack and consuming them to the extent possible. On the other hand, \bc{ROT} and its opposite, \bc{-ROT}\sepfootnote{02_08}, are often useful.

\subsection{The return stack and Its uses}
\TallC{We} have remarked above in \S2\S\S2 that compilation establishes links from the calling word to the previously- defined word being invoked. Part of the linkage mechanism --during actual execution-- is the \textbf{return stack} (rstack): the address of the next word to be invoked after the currently executing word is placed on the rstack, so that when the current word is done, the system jumps to the next word. Although it might seem logical to call the address on the rstack the \textbf{next} address, it is actually called the \textbf{return} address for historical reasons.

In addition to serving as a reservoir of return addresses (since words can be nested, the return addresses need a stack to be put on) the rstack is where the limits of a \bc{DO ... LOOP} construct are placed\sepfootnote{02_09}.

The user can also store/retrieve to/from the rstack This is an example of using a component for a purpose other than the one it was designed for. Such use is not encouraged by every FORTH text, needless to say, since it introduces the spice of danger. To store to the rstack we say \bc{>R}, and to retrieve we say \bc{R>}. \bc{DUP>R} is a speedup of the phrase \bc{DUP >R}. The words \bc{D>R DR>} , for maving double-length integers, also exist on many systems. The word \bc{R@} copies the top of the rstack to the TOS.

\leftbar[1\linewidth]
\textbf{The danger is this:} anything put on the rstack during a word’s execution must be removed before the word terminates. If the \bc{>R} and the \bc{R>} do not balance, then a \textbf{wrong next address} will be jumped to and \bc{EXECUTE}d. Since this could be the address of data, and since it is being interpreted as machine instructions, the results will be \textbf{always unpredictable}, but seldom amusing.
\endleftbar

\TallC{Why} would we want to use the rstack for storage when we have a perfectly good parameter stack to play with? Sometimes it becomes simply impossible to read code that performs complex gymnastics on the parameter stack, even though FORTH permits such gymnastics.

Consider a problem --say, drawing a line on a bit- mapped graphics output device from (x,y) to (x',y')-- that requires 4 arguments. We have to turn on the appropriate pixels in the memory area representing the display, in the ranges from the origin to the end coordinates of the line. Suppose we want to work with x and y first, but they are 3rd and 4th on the stack. So we have to \bc{ROLL} or \bc{PICK} to get them to TOS where they can be worked with conveniently. We probably need them again, so we use

\begin{lstlisting}
    4PICK 4PICK ( -- x y x' y' x y)
\end{lstlisting}

Now 6 arguments are on the stack! See what I mean? A better way stores temporarily the arguments x’ and y', leaving only 2 on the stack. If we need to duplicate them, we can do it with an already existing word, \bc{DDUP}.

Complex stack manipulations can be avoided by defining \bc{VARIABLE}s --named locations-- to store numbers. Since FORTH, variables are typically \textit{global} --any word can access them-- their use can lead to unfortunate and unexpected interactions among parts of a large program. Variables should be used sparingly.

While FORTH permits us to make variables local to the sub- if routines that use them\sepfootnote{02_10}, for many purposes the rstack can advantageously replace local variables:

\begin{itemize}
    \item The rstack already exists, so it need not be defined anew.
    \item When the numbers placed on it are removed, the rstack shrinks, thereby reclaiming some memory.
\end{itemize}

Suppose, in the previous example, we had put x’ and y’ on the rstack via the phrase

\begin{lstlisting}
    >R >R DDUP .
\end{lstlisting}

Then we could duplicate and access x and y with no trouble.

\leftbar[1\linewidth]
\underline{\textbf{A note of caution}}: since the rstack is a critical component of the execution mechanism, we mess with it at our peril. If we want to use it, we must clean up when we are done, so it is in the same state as when we found it. A word that places a number on the rstack must get it off again --using \bc{R>} or \bc{RDROP}-- before exiting that word\footnotemark. Similarly, since \bc{DO ... LOOP} uses the rstack also, for each \bc{>R} in such a loop (after \bc{DO}) there must be a corresponding \bc{R>} or \bc{RDROP} (before \bc{LOOP} is reached). Otherwise the results will be unpredictable and probably will crash the system.
\endleftbar

\footnotetext{{\textbf{RDROP} is a handy way to exit from a word before reaching the final ";". See \TF.}}

\section{Fetching and storing}

\TallC{Ordinary} (16-bit) numbers are f\textit{etc}hed from memory to the stack by "\bc{@}" ("fetch"), and stored by "\bc{!}" ("store"). The word @ expects an address on the stack and replaces that address by its contents using, \textit{e.g.}, the phrase \bc{X @}. The word "\regc{!}" expects a number (NOS) and an address (TOS) to store it in, and places the number in the memory location referred to by the address, consuming both arguments in the process, as in the phrase \bc{32 X !}

Double length (32-bit) numbers can similarly be f\textit{etc}hed and stored, by \bc{D@} and \bc{DI} . (FORTH systems designed for the newer 32-bit machines sometimes use a 32-bit-wide stack and may not distinguish between single- and double-length integers.)

Positive numbers smaller than 255 can be placed in single bytes of memory using \bc{C@} and \bc{C!}. This is convenient for operations with strings of ASCII text, for example screen, file and keyboard I/O.

In Chapters 3, 4, 5 and 7 we shall extend the lexicon of \bc{@} and \bc{!} words to include floating point and complex numbers.

\section{Arithmetic operations}

\TallC{The} 1979 or 1983 standards, not to mention the forthcoming ANSII standard, require that a conforming FORTH system contain a certain minimum set of predefined words. These consist of arithmetic operators \bc{+ - * / MOD /MOD */} for (usually) 16-bit \textit{signed-integer} (-32767 to +32767) arithmetic, and equivalents for \textit{unsigned} (0 to 65535), double-length and mixed-mode (16- mixed with 32-bit) arithmetic. The list will be found in the glossary accompanying your system, as well as in \SF and \FTR.

\section{Comparing and testlng}

\TallC{In} addition to arithmetic, FORTH lets us compare numbers on the stack, using relational operators \bc{> < =}.These operators work as follows: the phrase

\begin{lstlisting}
    2 3 > <cr> ok
\end{lstlisting}

will leave 0 ("false") on the stack, because 2 (N0S) is not greater
than 3 (TOS). Conversely, the phrase

\begin{lstlisting}
    2 3 < <cr> ok
\end{lstlisting}

will leave -1 ("true") because 2 is less than 3. Relational operators typically consume their arguments and leave a "flag" to show what happened\sepfootnote{02_12}. Those listed so far work with signed 16-bit integers. The operator \bc{U<} tests \textit{unsigned} 16-bit integers (0-65535).

FORTH offers unary relational operators \bc{0= 0>} and \bc{0<} that determine whether the TOS contains a (signed) 16-bit integer that is 0, positive or negative. Most FORTHs offer equivalent relational operators for use with double-length integers.

The relational words are used for branching and control. The usual form is

\begin{lstlisting}
    : MAYBE 0> IF WORDl WORD2 ...
      WORDn THEN ;
\end{lstlisting}

The word \bc{MAYBE} expects a number on the stack, and executes the words between \bc{IF} and \bc{THEN} if the number on the stack is positive, but not otherwise. If the number initially on the stack were negative or zero, \bc{MAYBE} would do nothing.

An alternate form including \bc{ELSE} allows two mutually exclusive actions:

\begin{lstlisting}
    : CHOOSE 0> IF WORD1 . . . WORDn
            ELSE WORDt' . . . WORDn'
            THEN ; (n -- )
\end{lstlisting}

If the number on the stack is positive, \bc{CHOOSE} executes \bc{WORD1 WORD2... WORD}, whereas if the number is negative or 0, \bc{CHOOSE} executes \bc{WORD1'} ... \bc{WORDn'}.

In either example, \bc{THEN} marks the end of the branch, rather than having its usual logical meaning\sepfootnote{02_13}.

\section{Looping and structured programming}

\TallC{FORTH} contains words for setting up loops that can be definite or indefinite:

\begin{lstlisting}
    BEGIN xxx flag UNTIL
\end{lstlisting}

The words represented by \bc{xxx} are executed, leaving the TOS (flag) set to 0 (F) -at which point \bc{UNTIL} leaves the loop - or -1 (T) -at which point \bc{UNTIL} makes the loop repeat from \bc{BEGIN}.

A variant is
\begin{lstlisting}
    BEGIN xxx flag WHILE yyy REPEAT
\end{lstlisting}

Here \bc{xxx} is executed, \bc{WHILE} tests the flag and if it is 0 (F) leaves the loop; whereas if flag is -1 (T) \bc{WHILE} executes \bc{yyy} and \bc{REPEAT} then branches back to \bc{BEGIN}. These forms can be used to set up loops that repeat until some external event (pressing a key at the keyboard, \textit{e.g.}) sets the flag to exit the loop. They can also used to make endless loops (like the outer interpreter of FORTH) by forcing flag to be 0 in a definition like

\begin{lstlisting}
    : ENDLESS BEGIN xxx 0 UNTIL ;
\end{lstlisting}

\TallC{FORTH} also implements indexed loops using the words \bc{DO LOOP +LOOP /LOOP}. These appear within definitions, \textit{e.g.}

\begin{lstlisting}
    : LOOP-EXAMPLE 100 0 DO xxx LOOP ;
\end{lstlisting}

The words \bc{xxx} will be executed 100 times as the lower limit, 0, increases in unit steps to 99. To step by -2's, we use the phrase

\begin{lstlisting}
    -2 + LOOP
\end{lstlisting}

to replace \bc{LOOP}, as in

\begin{lstlisting}
    : DOWN-BY-2's O 100 DO xxx -2 +LOOP ;
\end{lstlisting}

The word \bc{/LOOP} 1s a variant of \bc{+LOOP} for working with unsigned limits\sepfootnote{02_14} and increments (to permit the loop index to go up to 65535 in 16-bit systems).

\section{The pearl of FORTH}

An unusual construct, \bc{CREATE...DOES>}, has been called "the pearl of FORTH" \sepfootnote{02_15}. This is more than poetic license.

\bc{CREATE} is a component of the compiler that makes a new dictionary entry with a given name (the next name in the input stream) and has no other function.

\bc{DOES>} assigns a specific run-time action to a newly \bc{CREATE}d word (we shall see this in \S2\S\S8-3 below).

\subsection{Dummy words}
Sometimes we use \bc{CREATE} to make a dummy entry that we can later assign to some action:
\begin{lstlisting}
    CREATE DUMMY
    CA' * DEFINES DUMMY
\end{lstlisting}

The second line translates as "The code address of \bc{*} defines \bc{DUMMY}". Entry of the above phrase would let \bc{DUMMY} perform the job of \bc{*} just by saying \bc{DUMMY}. That is, FORTH lets us first define a dummy word, and then give it any other word’s meaning \sepfootnote{02_16}.

Here is one use of this power: Suppose we have to define two words that are alike except for some piece in the middle:
\begin{lstlisting}
    : *WORD  WORD1 WORD2 *  WORD3 WORD4 ;
    : */WORD WORD1 WORD2 */ WORD3 WORD4 ;
\end{lstlisting}

we could get away with 1 word, together with \bc{DUMMY} fromabove,

\begin{lstlisting}
    : *_or_*/WORD
        WORD1 WORD2
        DUMMY
        WORD3 WORD4 ;
\end{lstlisting}
by saying
\begin{lstlisting}
    CA' * DefinES DUMMY *_or_*/WORD
\end{lstlisting}
or
\begin{lstlisting}
    CA' */ DefinES DUMMY *_or_*/WORD
\end{lstlisting}

This technique, a rudimentary example of vectoring, saves memory and saves programming time by letting us vary something in the middle of a definition \textit{after the definition has been entered in the dictionary}. However, this technique must be used with caution as it is akin to \textbf{self-modifying} code\sepfootnote{02_17}.

A similar procedure lets a subroutine call itself recursively, an enormous help in coding certain algorithms.

\subsection{Defining "defining" words}

\TallC{The} title of this section is neither a typo nor a stutter: \bc{CREATE} finds its most important use in extending the powerful class of FORTH words called "defining" words. The colon compiler "\bc{:}" is such a word, as are \bc{VARIABLE} and \bc{CONSTANT}. The definition of \bc{VARIABLE} is simple

\begin{lstlisting}
    : VARIABLE CREATE 2 ALLOT ;
\end{lstlisting}

Here is how we use it:
\begin{lstlisting}
    VARIABLE X <cr> ok
\end{lstlisting}

The inner workings of VARIABLE are these:
\begin{itemize}
    \item \bc{CREATE} makes a dictionary entry with the next name in the input stream -- in this case, \bc{X}.
    \item Then the number 2 is placed on the stack, and the word \bc{ALLOT} increments the pointer that represents the current location in the dictionary by 2 bytes.
    \item This leaves a 2-byte vacancy to store the value of the variable (that is, the next dictionary header begins 2 bytes above the end of the one just defined).
\end{itemize}

When the outer interpreter loop encounters a new \bc{VARIABLE}'s name in the input stream, that name’s address is placed on the stack. But this is also the location where the 2 bytes of storage begins. Hence when we type in \bc{X}, the TOS will contain the storage address named \bc{X}.

As noted in \S2.4 above, the phrase \bc{X @} (pronounced "X f\textit{etc}h") places the contents of address \bc{X} on the stack, dropping the address in the process. Conversely, to store a value in the named location \bc{X}, we use \bc{!} ("store"): thus
\begin{lstlisting}
    4 X ! <cr> ok
    X @ . <cr> 4 ok
\end{lstlisting}

Double-length variables are defined \textit{via} \bc{DVARIABLE}, whose definition is

\begin{lstlisting}
    : DVARIABLE CREATE 4 ALLOT ;
\end{lstlisting}

\TallC{FORTH} has a method for defining words initialized to contain specific values: for example, we might want to define the number 17 to be a word. \bc{CREATE} and "\bc{,}" ("comma") let us do this as follows:

\begin{lstlisting}
    17 CREATE SEVENTEEN , <cr> ok
\end{lstlisting}

Now test it \textit{via}

\begin{lstlisting}
    SEVENTEEN @ . <cr> 17 ok
\end{lstlisting}

\leftbar[1\linewidth]
\Note: The word "," ("comma") puts TOS into the next 2 bytes of the dictionary and increments the dictionary pointer by 2.

A word \bc{C}, ("see-comma") puts a byte-value into the next byte of the dictionary and increments the pointer by 1 byte.
\endleftbar

\subsection{Run-time vs. compile-time actions}

\TallC{In} the preceding example, we were able to initialize the variable \bc{SEVENTEEN} to 17 when we \bc{CREATE}d it, but we still have to fetch it to the stack \textit{via} \bc{SEVENTEEN @} whenever we want it. This is not quite what we had in mind: we would like to find 17 in T0S when we say \bc{SEVENTEEN}. The word \bc{DOES>} gives us precisely the tool to do this.

As noted above, the function of \bc{DOES>} is to specify a run-time action for the "child" words of a defining word. Consider the defining word \bc{CONSTANT}, defined in high-level\sepfootnote{02_18} FORTH by

\begin{lstlisting}
    : CONSTANT CREATE , DOES> @ ;
\end{lstlisting}
and used as
\begin{lstlisting}
    53 CONSTANT PRIME ok
\end{lstlisting}

Now test it:
\begin{lstlisting}
    (*\bfseries PRIME*) . <cr> 53 ok
\end{lstlisting}

What happened?
\begin{itemize}
    \item \bc{CREATE} (hidden in \bc{CONSTANT}) made an entry (named \bc{PRIME} , the first word in the input stream following \bc{CONSTANT}). Then "\bc{,}" placed the TOS (the number 53) in the next two bytes of the dictionary.
    \item \bc{DOES>} (inside \bc{CONSTANT}) then appended the actions of all words between it and "\bc{;}" (the end of the definition of \bc{CONSTANT}) to the child word(s) defined by \bc{CONSTANT}.
    \item In this case, the only word between \bc{DOES>} and \bc{;} was \bc{@} , so all FORTH constants defined by \bc{CONSTANT} perform the action of placing their address on the stack (anything made by \bc{CREATE} does this) and fetching the contents of this address.
\end{itemize}

\subsubsection{Klingons}

\TallC{Let} us make a more complex example. Suppose we had previously defined a word \bc{BOX ( n x y -- )} that draws a small square box of n pixels to a side centered at (x, y) on the graphics display. We could use this to indicate the instantaneous location of a moving object -- say a Klingon space-ship in a space-war game.

So we define a defining word that creates (not very realistic looking) space ships as squares n pixels on a side:

\begin{lstlisting}
    : SPACE-SHIP CREATE , DOES>
        @-ROT (--nxy)      BOX ;
    : SIZE ; \ do-nothing word
\end{lstlisting}

Now, the usage would be (\bc{SIZE} is included merely as a reminder of what 5 means -- it has no function other than to make the definition look like an English phrase)

\begin{lstlisting}
    SIZE 5 SPACE-SHIP KLINGON <cr> ok
    71 35 KLINGON <cr> ok
\end{lstlisting}

Of course, \bc{SPACE-SHIP} is a poorly constructed defining word because it does not do what it is intended to do. Its child-word \bc{KLINGON} simply draws itself at (x, y).

What we really want is for \bc{KLINGON} to \textit{undraw} itself from its old location, compute its new position according to a set of rules, and then redraw itself at its new position This sequence of operations would require a definition more like

\begin{lstlisting}
    :OLD.POS@ (adr--adr n x y) DUP @ OVER
      2+ D@ :
    : SPACE-SHIP CREATE , 4 ALLOT DOES>
       OLD.POS@ UNBOX NEW.POS!
       OLD.POS@ BOX DROP ;
\end{lstlisting}

where the needed specialized operation \bc{UNBOX} would be defined previously along with \bc{BOX}.

\subsubsection{Dimensioned data (with intrinsic unlts)}
Here is another example of the power of defining words and of the distinction between compile-time and run-time behaviors.

Physical problems generally work with quantities that have dimensions, usually expressed as mass (M), length (L), and time (T) or products of powers of these. Sometimes there is more than one system of units in common use to describe the same phenomena.

For example, traffic police reporting accidents in the United States or the United Kingdom might use inches, feet, and yards; whereas Continental police would use the metric system. Rather than write different versions of an accident analysis program it is simpler to write one program and make unit conversions part of the grammar. This is easy in FORTH; impossible in FORTRAN, BASIC, Pascal, or C; and possible, but exceedingly cumbersomein Ada\sepfootnote{02_19}.

We simply keep all internal lengths in millimeters, say, and con-
vert as follows\sepfootnote{02_20}:

\begin{lstlisting}
    : INCHES  254 10 */ ;
    : FEET  [ 254 12 * ] LITERAL 10 */ ;
    : YARDS [ 254 36 * ] LITERAL 10 */ ;
    : CENTIMETERS 10 * ;
    : METERS 1000 * ;
\end{lstlisting}

The usage would be
\begin{lstlisting}
    10 FEET . <cr> 3048 ok
\end{lstlisting}

These are more definitions than necessary, of course, and the technique generates unnecessary code. A more compact approach uses a \textit{defining word}, \bc{UNITS}:

\begin{lstlisting}
    : D, SWAP , , ; \ I double-length # in next cells
    : UNITS CREATE D, DOES> D@ */ ;
\end{lstlisting}

Then we could make the table
\begin{lstlisting}
    254  10         UNITS INCHES
    254  12 * 10    UNITS FEET
    254  36 * 10    UNITS YARDS
     10   1         UNITS CENTIMETERS
    1000  1         UNITS METERS
    \ Usage:
    \ 10 FEET . <cr> 3048 ok
    \ 3  METERS . <cr> 3000 ok
    \ ......
    \ (*\etc*).
\end{lstlisting}

This is an improvement, but FORTH lets us do even better: here is a simple extension that allows conversion back to the input units, for use in output:

\begin{lstlisting}
    VARIABLE <AS>                \ new variable
    0 <AS> !                     \ initialize to "F"
    : AS -1 <AS> ! ;             \ set <AS> = "T"
    : UNITS CREATE D, DOES>
       D@                        \ get 2 #s
       <AS> @                    \ get current val.
          IF SWAP THEN           \ flip if "true"
      */   0 <AS> ! ;            \ convert, reset <AS>

    BEHEAD' <AS>          \ make it local for security(*\sepfootnote{02_21}*)
    \ unit definitions remain the same
    \ Usage:
    \ 10 FEET      . <cr> 3048 ok
    \ 3048 AS FEET . <cr> 10 ok
\end{lstlisting}

\subsection{Advanced methods of controlllng the compiler}

\TallC{FORTH} includes a technique for switching from compile mode to interpret mode while compiling or interpreting. This is done using the words \bc{]} and \bc{[} . (Contrary to intuition, \bc{]} turns the compiler on, \bc{[} turns it off.)

One use of \bc{]} and \bc{[} is to create an "action table" that allows us to choose which of several actions we would like to perform\sepfootnote{02_22}.

For example, suppose we have a series of push-buttons numbered 1-6, and a word \bc{WHAT} to read them.

That is, \bc{WHAT} waits for input from a keypad; when button \#3 is pushed, \eg, \bc{WHAT} leaves 3 on the stack.

We would like to use the word \bc{BUTTON} in the following way:

\begin{lstlisting}
    WHAT BUTTON
\end{lstlisting}

\bc{BUTTON} can be defined to choose its action from a table of
actions called \bc{BUTTONS} . We define the words as follows:

\begin{lstlisting}
    CREATE BUTTONS ] RING-BELL OPEN-DOOR
      ENTER LAUGH CRY SELF-DESTRUCT [
    : BUTTON 1- 2* BUTTONS + @ EXECUTE ;
\end{lstlisting}

If, as before, I push \#3, then the action \bc{ENTER} will be executed. Presumably button \#7 is a good one to avoid\sepfootnote{02_23}.

How does this work?
\begin{itemize}
    \item \bc{CREATE BUTTONS} makes a dictionary entry \bc{BUTTONS}.
    \item \bc{]} turns on the compiler: the previously-defined word-names \bc{RING-BELL}, \textit{etc.} are looked up in the dictionary and compiled into the table (as though we had begun with \bc{:}), rather than being executed.
    \item \bc{[} returns to interactive mode (as if it were ;), so that the next colon definition (\bc{BUTTON}) can be processed.
    \item The table \bc{BUTTONS} now contains the code-field addresses (CFA’s) of the desired actions of \bc{BUTTON}.
    \item \bc{BUTTON} first uses 1- to subtract 1 from the button number left on the stack by \bc{WHAT} (so we can use 0-based numbering into the table -- if the first button were \# 0, this would be unneeded).
    \item \bc{2*} then multiplies by 2 to get the offset (from the beginning of \bc{BUTTONS}) of the CFA representing the desired action.
    \item \bc{BUTTONS +} then adds the base address of \bc{BUTTONS} to get the absolute address where the desired CPA is stored.
    \item \bc{@} fetches the CFA for \bc{EXECUTE} to execute.
    \item \bc{EXECUTE} executes the word corresponding to the button pushed. Simple!
\end{itemize}

You may well ask "Why bother with all this indirection, pointers, pointers to pointers, tables of pointers to tables of pointers, and the like?" Why not just have nested \bc{IF...ELSE...THEN} constructs, as in Pascal?

There are three excellent reasons for using pointers:
\begin{itemize}
    \item Nested \bc{IF...THEN}'s uickly become cumbersome and difficult to decipher (\TF). They are also \underline{\textbf{slow}} (see Ch. 11).
    \item Changing pointers is generally much faster than changing other kinds of data -- for example reading in code overlays to accomplish a similar task.
    \item The unlimited depth of indirection possible in FORTH permits arbitrary levels of abstraction. This makes the computer behave more "intelligently" than might be possible with more restrictive languages.
\end{itemize}

A similar facility with pointers gives the C language its abstractive power, and is a major factor in its popularity.

\section{Strings}

\TallC{By} now it should be apparent that FORTH can do anything any other language can do. One feature we need in any sort of programming --scientific or otherwise-- is the ability to handle alphanumeric strings. We frequently want to print messages to the console, or to put captions on figures, even if we have no interest in major text processing.

While every FORTH system must include words to handle strings(see, e.g., \FTR Ch. 9) --the very functioning of the outer interpreter, compiler, \textit{etc.}, demands this-- there is little unanimity in defining extensions. BASIC has particularly good string-handling features, so HS/FORTH and others provide extensions designed to mimic BASIC’s string functions.

Typical FORTH strings are Iimite to 255 characters because they contain a count in their first byte\sepfootnote{02_24}.The word \bc{COUNT}
\begin{lstlisting}
    : COUNT DUP 1+ SWAP C@ ; (adf--nadr+1)
\end{lstlisting}

expects the address of a counted string, and places the count and
the address of the first character of the string on the stack. \bc{TYPE}, a required '79 or '83 word, prints the string to the console.

It is straightforward to employ words that are part of the system (such as \bc{KEY} and \bc{EXPECT}) to define a word like \bc{$"} that takes all characters typed at the keyboard up to a final \bc{"} (close-quote --not a word but a string-terminator), makes a counted string of them, and places the string in a buffer beginning at an address returned by \bc{PAD}\sepfootnote{02_25}.

The word \bc{$.} ("string-emit") could then be defined as
\begin{lstlisting}
    : $. COUNT TYPE ; (adr --)
\end{lstlisting}

and would be used with \bc{$"} like this:
\begin{lstlisting}
    $" The quick brown fox" < cr> ok
    $. The quick brown fox ok
\end{lstlisting}

Since this book in not an attempt to paraphrase \FTR it is strongly recommended that the details of using the system words to devise a string lexicon be studied there.

\leftbar[1\linewidth]
One might contemplate modifying the \FTR lexicon by using a full 16-bit cell for the count. This would permit strings of up to 64k bytes (using unsigned integers\footnotemark), wasting 1 byte of memory per short ( 255 bytes) string. Although few scientific applications need to manipulate such long strings, the program that generated the index to this book needed to read a page at a time, and thus to handle strings about 3-5 kbytes long.
\endleftbar
\footnotetext{\FTR, Ch. 3.}

\section{FORTH programming style}

\TallC{A} FORTH program typically looks like this
\begin{lstlisting}
    \ Example of FORTH program
    :WORD1 ... ;
    :WORD2 OTHER-WORDS ;
    :WORDS YET-OTHER-WORDS ;
       ...
    : LAST-WORD WORDn ...WORD3
       WORD2 WORD1 ;
    LAST-WORD <cr> \ run program
\end{lstlisting}

\leftbar[1\linewidth]
\Note: The word {\textbackslash } means "disregard the rest of this line". It is a convenient method for commenting code.
\endleftbar

In other words, a FORTH program consists of a series of word definitions, culminating in a definition that invokes the whole shebang. This aspect gives FORTH programming a somewhat different flavor from programming in more conventional languages.

Brodie notes in \TF that high-level programming languages are considered good if they require structured, top-down programming, and \textit{wonderful} if they impose \textit{information hiding}. Languages such as FORTRAN, BASIC and assembler that permit direct jumps and do not impose structure, top-down design and data-hiding are considered \textit{primitive} or bad. To what extent does FORTH follow the norms of good or \textit{wonderful} programming practice?

\subsection{Structure}

\TallC{The} philosophy of "structured programming" entered the general consciousness in the early 1970’s. The idea was to make the logic of program control flow immediately apparent, thereby aiding to produce correct and maintainable programs. The language Pascal was invented to impose by fiat the discipline of structure. To this end, direct jumps (GOTOs) were omitted from the language\sepfootnote{02_27}.

FORTH programs are automatically structured because word definitions are nothing but subroutine calls. The language contains no direct jump statements (that is, no GOTO's) so it is \textit{impossible} to write "spaghetti" code.

A second aspect of structure that FORTH imposes (or at least encourages) is \textit{short} definitions. There is little speed penalty incurred in breaking a long procedure into many small ones, unlike more conventional languages. Each of the short words has one entry and one exit point, and does one job. This is the beaux ideal of structured programming!

\subsection{"Top-down" design}

\TallC{Most} authors of "how to program" books recommend designing the entire program from the general to the particular. This is called "top-down" programming, and embodies these steps:

\begin{itemize}
    \item Make an outline, flow chart, data-flow diagram or whatever, taking a broad overview of the whole problem.
    \item Break the problem into small pieces (decompose it).
    \item Then code the individual components.
\end{itemize}

The natural programming mode in FORTH is "bottom-up" rather than "top-down" -- the most general word appears last, whereas the definitions necessarily progress from the primitive to the complex. It is possible -- and sometimes vital -- to invoke a word before it is defined ("forward referencing"\sepfootnote{02_28}). The dictionary and threaded compiler mechanisms make this nontrivial. The naturalness of bottom-up programming encourages a somewhat different approach from more familiar languages:

\begin{itemize}
    \item In FORTH, components are specified roughly, and then 3 they are coded they are immediately tested, debugged, redesigned and improved.
    \item The evolution of the components guides the evolution of the outer levels of the program.
\end{itemize}

We will observe this evolutionary style in later chapters as we design actual programs.

\subsection{Information hiding}

\TallC{Information} (or data) "hiding" is another doctrine of structured programming. It holds that no subroutine should have access to, or be able to alter (corrupt!) data that it does not absolutely require for its own functioning\sepfootnote{02_29}.

Data hiding is used both to prevent unforeseen interactions between pieces of a large program; and to ease designing and debugging a large program. The program is broken into small, manageable chunks ("black boxes") called \textbf{modules} or \textbf{objects} that communicate by sending messages to each other, but are otherwise mutually impenetrable. Information hiding and modularization are now considered so important that special languages --Ada, MODULA-Z, C++, and Object Pascal-- have been devised with it in mind.

To illustrate the problem information hiding is intended to solve, consider a FORTRAN program that calls a subroutine

\begin{lstlisting}
    PROGRAM MAIN
        some lines
    CALL SUB1(arg1, ar92, ... , argn, answer)
        some lines
    END

    SUB1(X1, ... , Xn, Y)
        some lines
        Y = something
    RETURN
    END
\end{lstlisting}

There are two ways to pass the arguments from MAIN to SUB1, and FORTRAN can use both methods.

\begin{itemize}
    \item Copy the arguments from where they are stored in MAIN into locations in the address space of SUBl (set aside for them during compilation). If the STATEMENTS change the values X1,...,Xn during execution of SUBl, the original values in the callin program will not be affected (because they are stored elsew ere and were copied during the CALL).
    \item Let SUBl have the addresses of the arguments where they are stored in MAIN. This method is dangerous because if the arguments are changed during execution of SUBl, they are changed in MAIN and are forever corrupted. If these changes were unintended, they can produce remarkable bugs.
\end{itemize}

Although copying arguments rather than addresses seems safer, sometimes this is impossible either because the increased memory overhead may be infeasible in problems with large amounts of data, or because the extra overhead of subroutine calls may unacceptably slow execution.

What has this to do with FORTH?

\begin{itemize}
    \item FORTH uses linked lists of addresses, compiled into a dictionary to which all words have equal right of access.
    \item Since everything in FORTH is a word --constants, variables, numerical operations, I/O procedures-- it might seem impossible to hide information in the sense described above.
    \item Fortunately, word-names can be erased from the dictionary after their CFAs have been compiled into words that call them. (This erasure is called "beheading".)
    \item Erasing the names of variables arantees they can be neither accessed nor corrupted by unauthorized words (except through a calamity so drea ful the program crashes).
\end{itemize}

\subsection{Documenting and commenting FORTH code}

\TallC{FORTH} is sometimes accused of being a "write-only" language. In other words, some complain that FORTH is cryptic. I feel this is basically a complaint against poor documentation and unhelpful word names, as Brodie and others have noted.

Unreadability is equally a flaw of poorly written FORTRAN, Pascal, C, \textit{et al}.

FORTH offers a programmer who takes the trouble a goodly array of tools for adequately documenting code.

\subsubsection{Parenthesized remarks}
The word ( --a left parenthesis followed by a space-- says "disregard all following text up until the next right parenthesis\sepfootnote{02_30} in the input stream. Thus we can intersperse explanatory remarks within colon definitions. This method was used to comment the Legendre polynomial example program in Ch. 1.

\subsubsection{Stack comments}
A particular form of parenthesized remark describes the effect of a word on the stack (or on the floating point fstack in Ch. 3). For example, the stack-effect comment (stack comment, for short)

\begin{lstlisting}
    ( adr - - n )
\end{lstlisting}

would be appropriate for the word \bc{@} ("fetch"): it says \bc{@} expects to find an address (adr) on the stack, and to leave its contents (n) upon completion.

The corresponding comment for \bc{!} would be
\begin{lstlisting}
    ( n adr --).
\end{lstlisting}

An fstack comment is prefaced by a double colon :: as
\begin{lstlisting}
    (::x -- f[x]).
\end{lstlisting}

Note that to replace parentheses within the comment we use brackets [ ] , since parentheses would be misinterpreted. Since the brackets appear to the right of the word \bc{(} , they cannot be (mis-)interpreted as the FORTH words \bc{]} or \bc{[}.

With some standard conventions for names\sepfootnote{02_31}, and standard abbreviations for different types of numbers, the stack comment may be all the documentation needed, especially for a short word.

\subsubsection{Drop line (\textbackslash)}
The word \textbackslash (back-slash followed by space) has gained favor as a method for including longer comments. It simply means "drop everything in the input stream until the next carriage return". Instructions to the user, clarifications or usage examples are most naturally expressed in an included block of text with each line set off\sepfootnote{02_32} by \textbackslash .

\subsubsection{Self-documenting code}
By eliminating ungrammatical phrases like \regc{CALL} or \regc{GOSUB}, FORTH presents the opportunity --\textit{via} telegraphic names\sepfootnote{02_33} for words-- to make code almost as self-documenting and transparent as a simple English or German sentence. Thus, for example, a robot control program could contain a phrase like

\begin{lstlisting}
    2 TIMES LEFT EYE WINK
\end{lstlisting}

which is clear (although it sounds like a stage direction for Brunhilde to vamp Siegfried). It would even be possible without much difficulty to define the words in the program so that the sequence could be made English-like:

\begin{lstlisting}
    WINK LEFT EYE 2 TIMES .
\end{lstlisting}

\subsection{Safety}

Some high level languages perform automatic bounds checking on arrays, or automatic type checking, thereby lending them a spurious air of reliability. FORTH has almost no error checking
of any sort, especially at run time. Nevertheless FORTH is a remarkably safe language since it fosters fine-grained decomposition into small, simple subroutines. And each subroutine can be checked as soon as it is defined. This combination of simplicity and immediacy can actually produce safer, more predictable code than languages like Ada, that are ostensibly \textit{designed} for safety.
\\

\leftbar[1\linewidth]
Nonetheless, error checking \textbf{--especialiy array bounds-checking--} can be a good idea during debugging. FORTH lets us include checks in an unobtrusive manner, by placing all the safety mechanisms in a word or words that can be "vectored" in or out as desired\footnotemark.
\endleftbar
\footnotetext{See \FTR for a more thorough discussion of vectoring. Brodie, \TF, sugests a nice construct called \bc{DOER...MAKE} that can be used for graceful vectoring.}
